const std = @import("std");
const shs = @import("./shs.zig");

const fs = std.fs;
const mem = std.mem;
const crypto = std.crypto;
const SessionKeys = shs.SessionKeys;
const Handshake = shs.Handshake;
const HandshakeOptions = shs.HandshakeOptions;

const log = std.log.scoped(.box);

pub const Header = struct {
    msg_len: usize,
    tag: [16]u8,
};

pub const header_size: usize = 34;
pub const max_payload_size: usize = 4096;

pub const BoxedConnection = struct {
    const FifoType = std.fifo.LinearFifo(u8, std.fifo.LinearFifoBufferType{
        .Static = header_size + max_payload_size,
    });

    // a fifo queue of decrypted bytes
    decrypted: FifoType = FifoType.init(),

    // holds keys generated by handshake
    session_keys: SessionKeys,

    // the underlying file/connection
    conn: fs.File,

    // orchestrates the handshake and saves session keys for future comms
    pub fn init(opts: HandshakeOptions, conn: fs.File) !BoxedConnection {
        var handshake = try Handshake.init(opts);

        var w = conn.writer();
        var r = conn.reader();

        var hello_msg: [64]u8 = undefined;
        handshake.hello(&hello_msg);
        var written = try w.write(&hello_msg);
        log.info("sent {} byte hello msg", .{written});

        var server_hello: [64]u8 = undefined;
        try r.readNoEof(&server_hello);
        log.info("received server hello msg", .{});

        var valid_hello = try handshake.verifyHello(&server_hello);
        if (!valid_hello) {
            log.err("server hello message is invalid", .{});
            return error.InvalidServerHello;
        }

        var auth_msg: [112]u8 = undefined;
        try handshake.auth(&auth_msg);
        written = try w.write(&auth_msg);
        log.info("sent {} byte auth msg", .{written});

        var server_auth: [80]u8 = undefined;
        r.readNoEof(&server_auth) catch |err| {
            std.log.err("incomplete auth msg returned; here's the buffer: {}", .{server_auth});
            return err;
        };
        log.info("received server auth msg", .{});

        var keys = try handshake.verifyAuth(&server_auth);

        log.info("handshake complete", .{});
        return BoxedConnection{
            .session_keys = keys,
            .conn = conn,
        };
    }

    // splits up payload into 4096-byte chunks and sends them encrypted down the wire
    pub fn write(self: *BoxedConnection, payload: []const u8) !usize {
        var buf: [header_size + max_payload_size]u8 = undefined;

        var written: usize = 0;
        var chunk_size = max_payload_size;
        var idx: usize = 0;
        while (idx < payload.len) : (idx += chunk_size) {
            var chunk = if (idx + chunk_size >= payload.len) payload[idx..] else payload[idx .. idx + chunk_size];
            var enc_size = self.seal(chunk, &buf);

            written += try self.conn.write(buf[0..enc_size]);
            log.info("wrote {} byte payload: {x}", .{ written, buf[0..enc_size] });
        }

        return written;
    }

    // will read as many bytes as possible into out
    pub fn read(self: *BoxedConnection, out: []u8) !usize {
        var out_idx: usize = 0;
        while (out_idx < out.len) {
            const written = self.decrypted.read(out[out_idx..]);
            if (written == 0) {
                // decrypted queue is empty; need to open more boxes
                if (try self.readNextHeader()) |header| {
                    const writable = try self.decrypted.writableWithSize(header.msg_len);
                    const n = try self.readNextBox(header, writable);
                    std.debug.assert(n == header.msg_len);
                    self.decrypted.update(n);
                } else {
                    // there isn't a next header; source has dried up
                    return out_idx;
                }
            }
            out_idx += written;
        }

        return out.len;
    }

    // reads out next header, or returns null if there isn't one
    pub fn readNextHeader(self: *BoxedConnection) !?Header {
        var header: [header_size]u8 = undefined;
        const n = try self.conn.read(&header);

        if (n != header_size) {
            return null;
        }

        var msg_header = try self.openHeader(header);

        return msg_header;
    }

    // reads out next box (as many bytes as specified in the provided header)
    pub fn readNextBox(self: *BoxedConnection, header: Header, out: []u8) !usize {
        std.debug.assert(out.len >= header.msg_len);

        var sized_out = out[0..header.msg_len];

        const n = try self.conn.read(sized_out);
        if (n != sized_out.len) {
            // could not read full body
            return error.EndOfStream;
        }

        try self.openBody(header, sized_out, sized_out);

        return header.msg_len;
    }

    // out must be 34 + msg.len in size; returns the sealed payload size
    pub fn seal(self: *BoxedConnection, msg: []const u8, out: []u8) usize {
        std.debug.assert(out.len >= msg.len + 34);
        std.debug.assert(msg.len <= 4096);

        var tag_nonce: [24]u8 = undefined;
        var body_nonce: [24]u8 = undefined;

        mem.copy(u8, &tag_nonce, &self.session_keys.send_nonce);
        increment(&self.session_keys.send_nonce);
        mem.copy(u8, &body_nonce, &self.session_keys.send_nonce);
        increment(&self.session_keys.send_nonce);

        // seal body into position 18 of out;
        // we'll chop off the 16-byte auth tag,
        // prepend the body length as 2-bytes, encrypt it (18-bytes),
        // and prepend it along with its own 16-byte auth tag
        // as the first 34-bytes in front of the original encrypted body
        crypto.nacl.SecretBox.seal(out[18 .. 18 + msg.len + 16], msg, body_nonce, self.session_keys.send_key);

        var tag: [18]u8 = undefined;
        mem.writeIntBig(u16, tag[0..2], @truncate(u16, msg.len));
        mem.copy(u8, tag[2..], out[18..34]);

        crypto.nacl.SecretBox.seal(out[0..34], &tag, tag_nonce, self.session_keys.send_key);

        return msg.len + 34;
    }

    pub fn openHeader(self: *BoxedConnection, header: [header_size]u8) !Header {
        var tag_nonce: [24]u8 = undefined;
        mem.copy(u8, &tag_nonce, &self.session_keys.recv_nonce);
        increment(&self.session_keys.recv_nonce);

        var out: [18]u8 = undefined;
        try crypto.nacl.SecretBox.open(&out, &header, tag_nonce, self.session_keys.recv_key);

        var msg_len = mem.readIntBig(u16, out[0..2]);

        var parsed_header = Header{
            .msg_len = msg_len,
            .tag = undefined,
        };

        mem.copy(u8, &parsed_header.tag, out[2..]);
        return parsed_header;
    }

    // out must be at least body.len
    pub fn openBody(self: *BoxedConnection, header: Header, body: []const u8, out: []u8) !void {
        std.debug.assert(out.len >= body.len);

        var body_nonce: [24]u8 = undefined;
        mem.copy(u8, &body_nonce, &self.session_keys.recv_nonce);
        increment(&self.session_keys.recv_nonce);

        var body_and_tag: [4130]u8 = undefined;
        mem.copy(u8, body_and_tag[0..], &header.tag);
        mem.copy(u8, body_and_tag[16..], body);

        var payload_len: usize = header.tag.len + header.msg_len;

        try crypto.nacl.SecretBox.open(out, body_and_tag[0..payload_len], body_nonce, self.session_keys.recv_key);
    }
};

// increment buffer, treating it as a big endian int
fn increment(buf: []u8) void {
    var idx: usize = buf.len - 1;
    var byte: u16 = 1;
    while (idx >= 0) : (idx -= 1) {
        byte += buf[idx];
        buf[idx] = @truncate(u8, byte);
        byte = byte >> 8;
        if (idx == 0) break;
    }
}

test "increment" {
    const Test = struct {
        input: []const u8,
        expected: []const u8,
    };
    const test_cases = [_]Test{
        Test{
            .input = &[_]u8{0x00},
            .expected = &[_]u8{0x01},
        },
        Test{
            .input = &[_]u8{ 0xff, 0xfe },
            .expected = &[_]u8{ 0xff, 0xff },
        },
        Test{
            .input = &[_]u8{ 0xff, 0xff },
            .expected = &[_]u8{ 0x00, 0x00 },
        },
    };

    var buf: [24]u8 = undefined;
    for (test_cases) |tc| {
        mem.copy(u8, buf[0..], tc.input);
        increment(buf[0..tc.input.len]);
        std.testing.expectEqualSlices(u8, buf[0..tc.input.len], tc.expected);
    }
}
